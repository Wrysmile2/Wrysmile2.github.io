<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伟伟超人`Blog</title>
  
  
  <link href="https://wrysmile2.github.io/atom.xml" rel="self"/>
  
  <link href="https://wrysmile2.github.io/"/>
  <updated>2023-12-19T13:36:43.243Z</updated>
  <id>https://wrysmile2.github.io/</id>
  
  <author>
    <name>安静苦笑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建k8s集群</title>
    <link href="https://wrysmile2.github.io/posts/704023d9.html"/>
    <id>https://wrysmile2.github.io/posts/704023d9.html</id>
    <published>2023-12-19T10:30:56.000Z</published>
    <updated>2023-12-19T13:36:43.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建Kubernetes集群（一）"><a href="#搭建Kubernetes集群（一）" class="headerlink" title="搭建Kubernetes集群（一）"></a>搭建Kubernetes集群（一）</h1><h2 id="Kubernetes基础概念"><a href="#Kubernetes基础概念" class="headerlink" title="Kubernetes基础概念"></a>Kubernetes基础概念</h2><h3 id="一、Kubernetes是什么"><a href="#一、Kubernetes是什么" class="headerlink" title="一、Kubernetes是什么"></a>一、Kubernetes是什么</h3><p>Kubernetes简称k8s，原因呢，是因为在第一个字母k和最后一个字母s中间，有8个字母，因此业内也称为k8s。k8s是为容器服务而生的一个可移植容器的编排管理工具。首先，我们从容器技术谈起，在容器技术之前，大家开发用虚拟机比较多，比如vmware和openstack，我们可以使用虚拟机在我们的操作系统中模拟出多台子电脑（Linux），子电脑之间是相互隔离的，但是虚拟机对于开发和运维人员而言，存在启动慢，占用空间大，不易迁移的缺点。</p><p>接着，容器化技术应运而生，它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境即可，而且启动速度很快，除了运行其中应用以外，基本不消耗额外的系统资源。Docker是应用最为广泛的容器技术，通过打包镜像，启动容器来创建一个服务。但是随着应用越来越复杂，容器的数量也越来越多，由此衍生了管理运维容器的重大问题，也就因此诞生了<strong>容器编排技术</strong>k8s。</p><p><img src="/posts/704023d9/project\Blog\source_posts\搭建k8s集群\1.png"></p><blockquote><p>我们急需一个大规模容器编排系统</p></blockquote><p>kubernetes具有以下特性：</p><ul><li><strong>服务发现和负载均衡</strong><br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li><li><strong>存储编排</strong><br>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</li><li><strong>自动部署和回滚</strong><br>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</li><li><strong>自动完成装箱计算</strong><br>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</li><li><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li><li><strong>密钥与配置管理</strong><br>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul><p><em><strong>Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</strong></em></p><h3 id="二、Kubernetes的架构"><a href="#二、Kubernetes的架构" class="headerlink" title="二、Kubernetes的架构"></a>二、Kubernetes的架构</h3><h4 id="1、工作方式"><a href="#1、工作方式" class="headerlink" title="1、工作方式"></a>1、工作方式</h4><blockquote><p>Kubernetes <strong>Cluster</strong> <strong>&#x3D;</strong> N <strong>Master</strong> Node <strong>+</strong> N <strong>Worker</strong> Node：N主节点+N工作节点； N&gt;&#x3D;1</p></blockquote><h4 id="2、组件架构"><a href="#2、组件架构" class="headerlink" title="2、组件架构"></a>2、组件架构</h4><p><img src="/posts/704023d9/project\Blog\source_posts\搭建k8s集群\2.png"></p><h4 id="3、控制平面组件（Control-Plane-Components）"><a href="#3、控制平面组件（Control-Plane-Components）" class="headerlink" title="3、控制平面组件（Control Plane Components）"></a>3、控制平面组件（Control Plane Components）</h4><p>控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">pod</a>）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/">使用 kubeadm 构建高可用性集群</a> 中关于多 VM 控制平面设置的示例。</p><h5 id="（1）kube-apiserver"><a href="#（1）kube-apiserver" class="headerlink" title="（1）kube-apiserver"></a>（1）kube-apiserver</h5><p>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane">控制面</a>的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p><h5 id="（2）etcd"><a href="#（2）etcd" class="headerlink" title="（2）etcd"></a>（2）etcd</h5><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p><p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h5 id="（3）kube-scheduler"><a href="#（3）kube-scheduler" class="headerlink" title="（3）kube-scheduler"></a>（3）kube-scheduler</h5><p>控制平面组件，负责监视新创建的、未指定运行<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a>，选择节点让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件&#x2F;软件&#x2F;策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h5 id="（4）kube-controller-manager"><a href="#（4）kube-controller-manager" class="headerlink" title="（4）kube-controller-manager"></a>（4）kube-controller-manager</h5><p>在主节点上运行 <a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a> 的组件。</p><p>从逻辑上讲，每个<a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</li></ul><h5 id="（5）cloud-controller-manager"><a href="#（5）cloud-controller-manager" class="headerlink" title="（5）cloud-controller-manager"></a>（5）cloud-controller-manager</h5><p>云控制器管理器是指嵌入特定云的控制逻辑的 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 云控制器管理器允许您链接集群到云提供商的应用编程接口中， 并把和该云平台交互的组件与只和您的集群交互的组件分离开。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li></ul><h3 id="三、Node-组件"><a href="#三、Node-组件" class="headerlink" title="三、Node 组件"></a>三、Node 组件</h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>一个在集群中每个<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>上运行的代理。 它保证<a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都 运行在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个节点上运行的网络代理， 实现 Kubernetes <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p><p><img src="/posts/704023d9/project\Blog\source_posts\搭建k8s集群\3.png"></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>好了，以上就是Kubernetes的基础概念，下一章我们将开始正式搭建Kubernetes集群。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建Kubernetes集群（一）&quot;&gt;&lt;a href=&quot;#搭建Kubernetes集群（一）&quot; class=&quot;headerlink&quot; title=&quot;搭建Kubernetes集群（一）&quot;&gt;&lt;/a&gt;搭建Kubernetes集群（一）&lt;/h1&gt;&lt;h2 id=&quot;Kuber</summary>
      
    
    
    
    <category term="云计算" scheme="https://wrysmile2.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="Kubernetes" scheme="https://wrysmile2.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的锁机制</title>
    <link href="https://wrysmile2.github.io/posts/5332072f.html"/>
    <id>https://wrysmile2.github.io/posts/5332072f.html</id>
    <published>2023-10-07T10:14:28.000Z</published>
    <updated>2023-10-16T09:50:40.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql的锁机制"><a href="#Mysql的锁机制" class="headerlink" title="Mysql的锁机制"></a>Mysql的锁机制</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在数据库中，除传统的计算资源（如CPU、RAM、&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL锁可以按模式分类为：乐观锁与悲观锁。按粒度分可以分为全局锁、表级锁、页级锁、行级锁。按属性可以分为：共享锁、排它锁。按状态分为：意向共享锁、意向排它锁。按算法分为：间隙锁、临键锁、记录锁。</p><h3 id="一、全局锁、表级锁、页级锁、行级锁"><a href="#一、全局锁、表级锁、页级锁、行级锁" class="headerlink" title="一、全局锁、表级锁、页级锁、行级锁"></a>一、全局锁、表级锁、页级锁、行级锁</h3><h4 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1.全局锁"></a>1.全局锁</h4><p><strong>（1）概念</strong>：全局锁就是对整个数据库实现例加锁</p><p><strong>（2）应用场景</strong>：全库逻辑备份</p><p><strong>（3）实现方式</strong>：</p><blockquote><p>MySQL 提供了一个加全局读锁的方法，命令是Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p></blockquote><p><strong>（4）风险点</strong>：</p><blockquote><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。</p><p>如果在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p></blockquote><h4 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a>2.表级锁</h4><p><strong>（1）概念</strong>：当前操作的整张表加锁，最常使用的 MyISAM 与 InnoDB 都支持表级锁定。MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p><strong>（2）实现方式</strong>：</p><blockquote><p>表锁：lock tables … read&#x2F;write；</p><p>例如lock tables t1 read, t2 write; 命令，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能在unlock tables之前访问其他表。</p><p>元数据锁：MDL 不需要显式使用，在访问一个表的时候会被自动加上，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p></blockquote><p><strong>（3）风险点</strong>：</p><blockquote><p>参考于：<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/keme/p/11065025.html">www.cnblogs.com/keme/p/1106…</a></p><p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。</p><ol><li>sessionA:</li></ol><p><strong>begin;</strong></p><p><strong>select* from t limit 1;</strong></p><ol start="2"><li>sessionB:</li></ol><p><strong>select* from t limit 1;</strong></p><ol start="3"><li>sessionC:</li></ol><p><strong>altertable t add f int;</strong></p><p>#会mdl锁住</p><ol start="4"><li>sessionD:</li></ol><p><strong>select* from t limit 1;</strong></p><p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于session B 需要的也是 MDL 读锁，因此可以正常执行。</p><p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 sessionC 需要MDL 写锁，因此只能被阻塞。</p><p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被session C 阻塞。前面说了，<code>所有对表的增删改查操作都需要先申请MDL 读锁，而这时读锁没有释放，对表alter ，产生了mdl写锁，把表t锁住了，这时候就对表t完全不可读写了</code>。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session 再请求的话，这个库的线程很快就会爆满。</p><p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。<br> <code>**注 ：一般行锁都有锁超时时间。但是MDL锁没有超时时间的限制，只要事务没有提交就会一直锁注。**</code></p></blockquote><p><strong>（4）解决办法</strong>：</p><blockquote><p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。这也是为什么需要在低峰期做ddl 变更。</p></blockquote><h4 id="3-页级锁"><a href="#3-页级锁" class="headerlink" title="3.页级锁"></a>3.页级锁</h4><p><strong>（1）概念</strong>：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 引擎支持页级锁。</p><h4 id="4-行级锁"><a href="#4-行级锁" class="headerlink" title="4.行级锁"></a>4.行级锁</h4><p><strong>（1）概念</strong>：行级锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。MySQL中只有InnoDB支持行级锁，行级锁分为共享锁和排他锁。</p><p><strong>（2）实现方式</strong>：</p><blockquote><p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p></blockquote><h3 id="二、乐观锁和悲观锁"><a href="#二、乐观锁和悲观锁" class="headerlink" title="二、乐观锁和悲观锁"></a>二、乐观锁和悲观锁</h3><h4 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1.乐观锁"></a>1.乐观锁</h4><p><strong>（1）概念</strong>：乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p><strong>（2）应用场景</strong>：适用于读多写少，因为如果出现大量的写操作，写冲突的可能性就会增大，业务层需要不断重试，会大大降低系统性能。</p><p><strong>（3）实现方式</strong>：</p><blockquote><p>一般使用数据版本（Version）记录机制实现，在数据库表中增加一个数字类型的“version”字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p></blockquote><img src="/posts/5332072f/5332072f/%E4%B9%90%E8%A7%82%E9%94%81.jpg" class><h4 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2.悲观锁"></a>2.悲观锁</h4><p><strong>（1）概念</strong>：悲观锁，正如其名，具有强烈的独占和排他特性，每次去拿数据的时候都认为别人会修改，对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。</p><p><strong>（2）应用场景</strong>：适用于并发量不大、写入操作比较频繁、数据一致性比较高的场景。</p><p><strong>（3）实现方式</strong>：在MySQL中使用悲观锁，必须关闭MySQL的自动提交，set autocommit&#x3D;0。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><h3 id="三、共享锁和排它锁"><a href="#三、共享锁和排它锁" class="headerlink" title="三、共享锁和排它锁"></a>三、共享锁和排它锁</h3><h4 id="1-共享锁"><a href="#1-共享锁" class="headerlink" title="1.共享锁"></a>1.共享锁</h4><p><strong>（1）概念</strong>：共享锁，又称之为读锁，简称S锁，当事务A对数据加上读锁后，其他事务只能对该数据加读锁，不能做任何修改操作，也就是不能添加写锁。只有当事务A上的读锁被释放后，其他事务才能对其添加写锁。</p><p><strong>（2）应用场景</strong>：</p><blockquote><p>共享锁主要是为了支持并发的读取数据而出现的，读取数据时，不允许其他事务对当前数据进行修改操作，从而避免”不可重读”的问题的出现。</p><p>适合于两张表存在关系时的写操作，拿mysql官方文档的例子来说，一个表是child表，一个是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条child_id&#x3D;100记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条c_child_id&#x3D;100的记录，那么业务数据就存在不一致的风险。正确的方法是再插入时执行select * from parent where c_child_id&#x3D;100 lock in share mode,锁定了parent表的这条记录，然后执行insert into child(child_id)values (100)就不会存在这种问题了。</p></blockquote><p><strong>（3）实现方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select …lock in share mode</span><br></pre></td></tr></table></figure><h4 id="2-排它锁"><a href="#2-排它锁" class="headerlink" title="2.排它锁"></a>2.排它锁</h4><p><strong>（1）概念:</strong></p><p>排它锁，又称之为写锁，简称X锁，当事务对数据加上写锁后，其他事务既不能对该数据添加读写，也不能对该数据添加写锁，写锁与其他锁都是互斥的。只有当前数据写锁被释放后，其他事务才能对其添加写锁或者是读锁。</p><p>MySQL InnoDB引擎默认update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p><p><strong>（2）应用场景：</strong></p><p>写锁主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而可以有效避免”脏读”问题的产生。</p><p><strong>（3）实现方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select …for update</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上是我对Mysql的锁机制的一些了解和总结，欢迎小伙伴在评论区补充！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql的锁机制&quot;&gt;&lt;a href=&quot;#Mysql的锁机制&quot; class=&quot;headerlink&quot; title=&quot;Mysql的锁机制&quot;&gt;&lt;/a&gt;Mysql的锁机制&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Mysql" scheme="https://wrysmile2.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的MVCC机制</title>
    <link href="https://wrysmile2.github.io/posts/368c6375.html"/>
    <id>https://wrysmile2.github.io/posts/368c6375.html</id>
    <published>2023-10-07T10:13:47.000Z</published>
    <updated>2023-10-19T01:33:54.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql的MVCC机制"><a href="#Mysql的MVCC机制" class="headerlink" title="Mysql的MVCC机制"></a>Mysql的MVCC机制</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在之前的文章中，我们提到了Mysql的事务和ACID性质，那么数据库是如何保证隔事务的离性呢？数据库是通过<strong>加锁</strong>，来实现事务的隔离性的。这就好像，如果你想一个人静静，不被别人打扰，你就可以在房门上加上一把锁。</p><p>加锁确实好使，可以保证隔离性。比如<strong>串行化隔离级别就是加锁实现的</strong>。但是频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大<strong>降低了数据库性能</strong>。</p><p><strong>那么，如何解决加锁后的性能问题的？</strong></p><p>答案就是,<strong>MVCC多版本并发控制</strong>！它实现读取数据不用加锁，可以让读取数据同时修改。修改数据时同时可读取。</p><h3 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1.什么是MVCC"></a>1.什么是MVCC</h3><p>MVCC，即<strong>Multi-Version Concurrency Control （多版本并发控制）</strong>。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><blockquote><p>通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。</p></blockquote><p>数据库隔离级别读<strong>已提交、可重复读</strong> 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。</p><h3 id="2-MVCC实现的关键知识"><a href="#2-MVCC实现的关键知识" class="headerlink" title="2.MVCC实现的关键知识"></a>2.MVCC实现的关键知识</h3><h4 id="2-1-事务版本号"><a href="#2-1-事务版本号" class="headerlink" title="2.1 事务版本号"></a>2.1 事务版本号</h4><blockquote><p>事务每次开启前，都会从数据库获得一个自增长的事务ID，可以从事务ID去判断事务的执行顺序，这就是事务版本号。</p></blockquote><h4 id="2-2-隐式字段"><a href="#2-2-隐式字段" class="headerlink" title="2.2 隐式字段"></a>2.2 隐式字段</h4><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>单调递增的行ID，不是必需的，占用6个字节。</td></tr><tr><td>trx_id</td><td>是</td><td>记录操作该数据事务的事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>这个隐藏列就相当于一个指针，指向回滚段的undo日志</td></tr></tbody></table><h4 id="2-3-undo-log"><a href="#2-3-undo-log" class="headerlink" title="2.3 undo log"></a>2.3 undo log</h4><p>undo log，<strong>回滚日志</strong>，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。</p><p>可以这样认为，当delete一条记录时，undo log中记录一条对应的insert记录，当update一条记录时，它记录一条对应的相反的update记录。</p><p>哪undo log有什么用途呢？</p><ol><li>事务回滚时，保证原子性和一致性</li><li>用于MVCC快照读</li></ol><h4 id="2-4-版本连"><a href="#2-4-版本连" class="headerlink" title="2.4 版本连"></a>2.4 版本连</h4><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。如下：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql的MVCC机制&quot;&gt;&lt;a href=&quot;#Mysql的MVCC机制&quot; class=&quot;headerlink&quot; title=&quot;Mysql的MVCC机制&quot;&gt;&lt;/a&gt;Mysql的MVCC机制&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Mysql" scheme="https://wrysmile2.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>api和接口的区别</title>
    <link href="https://wrysmile2.github.io/posts/37274a39.html"/>
    <id>https://wrysmile2.github.io/posts/37274a39.html</id>
    <published>2023-10-06T03:10:22.000Z</published>
    <updated>2023-10-16T09:50:40.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="api和接口的区别"><a href="#api和接口的区别" class="headerlink" title="api和接口的区别"></a>api和接口的区别</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在日常的学习过程中，我们会听到接口和api的这两种说法，但是并不清楚两者有什么区别，下面总结一下他人的回答以及我自己的理解。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="日常生活中的接口"><a href="#日常生活中的接口" class="headerlink" title="日常生活中的接口"></a>日常生活中的接口</h4><p>拿手机充电口举例，有Micro USB接口的，有type-c接口的，还有Lightning接口（ios设备），这三个接口就是一个接口定义，规定了这个充电口的形状、大小，但是你应用于这些接口在哪些品牌的手机上、怎么实现充电、是否做成快充，我都不关心，你只要符合形状、大小，你都属于这个接口。</p><h4 id="编程语言的接口"><a href="#编程语言的接口" class="headerlink" title="编程语言的接口"></a>编程语言的接口</h4><p>编程语言角度的接口：</p><p>指的是具体的一种语法规则（如java语言中用 interface定义接口类型）</p><p>比如有两个类都想实现同一个功能，就可以定义一个接口，然后在接口中声明一个方法（抽象方法，只是声明，并不能实现），然后让这两个类继承接口，从而通过不同的类来重写实现这个方法，实现多态，减少代码的冗余。</p><p>（同上理解：我们只关心类实现了接口中声明的方法，并不关心实际上引用的是哪个类的对象。通过传入接口的不同实现类的对象，从而在不改变调用方代码的情况向下改变程序的功能，实现多态）</p><h3 id="api接口"><a href="#api接口" class="headerlink" title="api接口"></a>api接口</h3><h4 id="应用程序角度的接口"><a href="#应用程序角度的接口" class="headerlink" title="应用程序角度的接口"></a>应用程序角度的接口</h4><h5 id="内部接口"><a href="#内部接口" class="headerlink" title="内部接口"></a>内部接口</h5><p>最常见的就是开发过程中，后端开发写好了一个方法，封装成了一个接口，供前端开发人员调用。我们就可以通过在页面上的操作，来实现某个特定的功能，这种接口就属于api接口。在springcloud的组件中OpenFeign就是一个基于注解的声明式Web服务客户端，它简化了使用HTTP API的过程，开发人员可以使用该组件定义和调用api接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;service-user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInfoFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin/user/userInfo/inner/getById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上图就是定义了一个内部接口，可供开发人员调用。</p><h5 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h5><p>同理，当我们开发某些功能需要调用第三方接口时（比如支付功能），需要调用支付宝的第三方接口来实现支付功能，这种第三方接口，也属于api接口。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>interface是在代码中使用的接口,api是提供给外部使用的程序接入点。</p><p>前者是编程语言中使用的,没有具体实现的抽象的定义</p><p>后者其实是一个已经包含了逻辑的可执行的程序,供外部使用的。</p><p>以上就是我整理的对于接口与API的理解，如果有不对的地方欢迎指出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;api和接口的区别&quot;&gt;&lt;a href=&quot;#api和接口的区别&quot; class=&quot;headerlink&quot; title=&quot;api和接口的区别&quot;&gt;&lt;/a&gt;api和接口的区别&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="接口" scheme="https://wrysmile2.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂</title>
    <link href="https://wrysmile2.github.io/posts/6833528b.html"/>
    <id>https://wrysmile2.github.io/posts/6833528b.html</id>
    <published>2023-10-02T05:10:58.000Z</published>
    <updated>2023-10-02T05:51:50.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式—工厂"><a href="#设计模式—工厂" class="headerlink" title="设计模式—工厂"></a>设计模式—工厂</h1><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h4 id="工厂模式包含以下几个核心角色"><a href="#工厂模式包含以下几个核心角色" class="headerlink" title="工厂模式包含以下几个核心角色"></a>工厂模式包含以下几个核心角色</h4><ul><li>抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。</li><li>具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。</li><li>抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。</li><li>具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。</p><p><em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE</em>），以便获取它所需对象的类型。</p><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>创建一个接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>创建实现接口的实体类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>创建一个工厂，生成基于给定信息的实体类的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    </span><br><span class="line">   //使用 getShape 方法获取形状类型的对象</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      if(shapeType == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">         return new Circle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">         return new Square();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h4><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ShapeFactory shapeFactory = new ShapeFactory();</span><br><span class="line"> </span><br><span class="line">      //获取 Circle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"> </span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"> </span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      //获取 Square 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"> </span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h4><p>执行错误，输出结果：</p><blockquote><p>Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式—工厂&quot;&gt;&lt;a href=&quot;#设计模式—工厂&quot; class=&quot;headerlink&quot; title=&quot;设计模式—工厂&quot;&gt;&lt;/a&gt;设计模式—工厂&lt;/h1&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="后端" scheme="https://wrysmile2.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="设计模式" scheme="https://wrysmile2.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务的隔离级别</title>
    <link href="https://wrysmile2.github.io/posts/f3c852d2.html"/>
    <id>https://wrysmile2.github.io/posts/f3c852d2.html</id>
    <published>2023-09-30T04:49:29.000Z</published>
    <updated>2023-09-30T05:41:53.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql事务的隔离级别"><a href="#Mysql事务的隔离级别" class="headerlink" title="Mysql事务的隔离级别"></a>Mysql事务的隔离级别</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们之前介绍过Mysql的存储引擎，其中只有InnoDB支持事务，然而提到事务就一定会考虑到隔离级别，今天我们来整理一下Mysql事务的四大隔离级别相关知识，希望对大家有所帮助。</p><h3 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h3><p>数据库事务指的是一组数据操作，事务内的操作要么就全部成功，要么就全部失败，什么都不做，其实不是没做，是可能只做了一部分，但只要有一步失败，就要回滚所有操作。</p><p>在事务的使用中，我们会遇到一些相关问题，一般会有三种情况：<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>，这是事务并发可能会出现的情况。</p><h4 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h4><blockquote><p>脏读指的是：一个事务读到了另一个未提交事务修改过的数据，未提交意味着这些数据可能会回滚，也可能最终没有保存到数据库中，所以就导致了读到的数据不一定是真实的数据。这就是脏读。</p></blockquote><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><blockquote><p>可重复读指的是在同一个事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如当一个事务在大量读取数据时，有一其他事务对该数据进行了修改，这就会导致之后读取到的数据会与修改前不一致。这就是不可重复读，通常针对数据更新（update）操作。</p></blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><blockquote><p>幻读是针对数据<strong>插入（insert）</strong>操作来说的。假设事务A对某些数据做了修改，但是还没有提交事务，此时事务B插入了与事务A更改前的记录相同的数据，并且在事务A提交之前提交了，而这时，在事务A中查询，会发现好像刚刚的更改对某些数据不起作用，但这其实是事务B插入进来的，对于用户来说，就想中了幻术一样，这就是幻读。</p></blockquote><p>这三种是事务的实现中会发生的三种异常，使用Mysql定义的隔离级别可以避免它，我们之前讲过，Mysql的事务实现逻辑是位于引擎层的，但不是所有存储引擎都支持事务，下面我们所讲述的隔离级别都是以InnoDB存储引擎来描述。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>隔离性（isolation）指的是不同事务先后提交并执行后，最终呈现出来的效果是串行的，也就是说，对于事务来说，它在执行过程中，感知到的数据变化应该只有自己操作引起的，不存在其他事务引发的数据变化。</p><p><strong>隔离性解决的是并发事务出现的问题</strong>。</p><h3 id="SQL的隔离级别"><a href="#SQL的隔离级别" class="headerlink" title="SQL的隔离级别"></a>SQL的隔离级别</h3><p>隔离性最简单的实现方式就是各个事务都串行执行了，如果前面的事务还没有执行完毕，后面的事务就都等待。但是这样的实现方式很明显并发效率不高，并不适合在实际环境中使用。</p><p>为了解决上述问题，实现不同程度的并发控制，SQL的标准制定者提出了不同的隔离级别：未提交读（read uncommitted）、提交读（read committed）、可重复读（repeatable read）、序列化读（serializable）。其中最高级隔离级别就是序列化读，而在其他隔离级别中，由于事务是并发执行的，所以或多或少允许出现一些问题。见以下的矩阵表：</p><table><thead><tr><th align="left">隔离级别（+:允许出现，-：不允许出现）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="left">读未提交（RU）</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">读已提交</td><td align="center">-</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">可重复度</td><td align="center">-</td><td align="center">-</td><td align="center">+</td></tr><tr><td align="left">序列化</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p><strong>注意，MySQL的InnoDB引擎在提交读级别通过MVCC解决了不可重复读的问题，在可重复读级别通过间隙锁解决了幻读问题，具体见下面的分析</strong>。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>标准SQL事务隔离级别实现原理</strong></p><p>我们上面遇到的问题其实就是并发事务下的控制问题，解决并发事务的最常见方式就是悲观并发控制了（也就是数据库中的锁）。标准SQL事务隔离级别的实现是依赖锁的，我们来看下具体是怎么实现的：</p><table><thead><tr><th>事务隔离级别</th><th>实现方式</th></tr></thead><tbody><tr><td>读未提交（RU）</td><td>事务对当前被读取的数据不加锁； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放。</td></tr><tr><td>读已提交（RC）</td><td>事务对当前被读取的数据加<strong>行级共享锁（当读到时才加锁）</strong>，一旦读完该行，立即释放该行级共享锁； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级排他锁</strong>，直到事务结束才释放。</td></tr><tr><td>可重复读（RR）</td><td>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级排他锁</strong>，直到事务结束才释放。</td></tr><tr><td>序列化（S）</td><td>事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放； 事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</td></tr></tbody></table><p>可以看到，在只使用锁来实现隔离级别的控制的时候，需要频繁的加锁解锁，而且很容易发生读写的冲突（例如在RC级别下，事务A更新了数据行1，事务B则在事务A提交前读取数据行1都要等待事务A提交并释放锁）。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是我对Mysql的隔离级别的一些看法和总结，欢迎小伙伴在评论区补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql事务的隔离级别&quot;&gt;&lt;a href=&quot;#Mysql事务的隔离级别&quot; class=&quot;headerlink&quot; title=&quot;Mysql事务的隔离级别&quot;&gt;&lt;/a&gt;Mysql事务的隔离级别&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Mysql" scheme="https://wrysmile2.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的执行流程</title>
    <link href="https://wrysmile2.github.io/posts/10a134a.html"/>
    <id>https://wrysmile2.github.io/posts/10a134a.html</id>
    <published>2023-09-26T13:03:07.000Z</published>
    <updated>2023-09-30T00:56:39.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql的执行流程"><a href="#Mysql的执行流程" class="headerlink" title="Mysql的执行流程"></a>Mysql的执行流程</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Mysql是我们在开发中经常用到的中间件，了解sql语句在MySQL的执行步骤，对我们从查询语句、mysql配置、数据恢复等方面优化mysql的性能有很大帮助。</p><h3 id="Mysql的整体架构"><a href="#Mysql的整体架构" class="headerlink" title="Mysql的整体架构"></a>Mysql的整体架构</h3><p>以下为MySQL数据库中SQL语句在的简要执行流程</p><img src="/posts/10a134a/10a134a/20210711173835627.jpg" class><p>简单来说 MySQL 主要分为 Server 层和存储引擎层。<strong>Server层</strong>主要包括连接器、查询缓存、分析器、优化器、执行器等，还有一个通用binlog日志模块(用于整个数据库操作记录，主从复制的关键)。存储引擎层主要负责数据的存储和读取。</p><h4 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h4><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。一般使用数据库管理工具(eg:Navicat)或者在安装mysql的服务器直接输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">root@bac8f643c3e9:/# <span class="title">mysql</span> -<span class="title">h10</span>.10.0.18 -<span class="title">p3306</span> -<span class="title">uroot</span> -<span class="title">p</span></span></span><br></pre></td></tr></table></figure><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p><h4 id="2-查询缓存-MySQL-8-0-版本后移除"><a href="#2-查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="2. 查询缓存(MySQL 8.0 版本后移除)"></a>2. 查询缓存(MySQL 8.0 版本后移除)</h4><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。<strong>当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件</strong>。</p><p><strong>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</strong></p><p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p><p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p><h4 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3.分析器"></a>3.分析器</h4><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p><blockquote><p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p></blockquote><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><p><strong>大部分sql执行报错都在分析器这一步</strong></p><h4 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4.优化器"></a>4.优化器</h4><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p><p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p><h4 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5.执行器"></a>5.执行器</h4><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><p><strong>这里说明一下为什么查询表的执行权限不在优化器之前检测？</strong></p><p><strong>是因为有些时候，SQL语句要操作的表不只是SQL字面上那些。比如如果有个触发器，得在执行器阶段（过程中）才能确定。优化器阶段前是无能为力的。</strong></p><h3 id="一条SQL的生命历程"><a href="#一条SQL的生命历程" class="headerlink" title="一条SQL的生命历程"></a>一条SQL的生命历程</h3><p>了解了Mysql的整体架构后，我们来分析一下一条SQL语句的执行过程</p><ol><li>一条SQL的诞生首先需要通过某种方式传递给<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>。数据库会有一个客户端用来与外界交流，而作为提交SQL的一方，可以通过ODBC或者是JDBC协议直接将SQL提交给数据库，除此以外，还可以通过Web服务等第三方服务将SQL提交给数据库。</li><li>数据库接受SQL语句后，会根据现有的情况预先计算相应的算力，决定是不是应该立即执行这条SQL以及是否有足够的资源执行完这句SQL。一般这个任务被称为“Process Manager”。</li><li>当这条SQL获得相应的算力后，SQL就会开始进行计算了，首先会调用语句处理器，检查调用者是否有足够权限执行这条SQL，接下来编译这条SQL文本成内部执行计划。内部执行计划会包含各种“算子”，例如聚合，投影，选择以及join。</li><li>在执行计划中会存在很多算子，这时需要一个事务处理器帮忙决定数据的增删改查。存储系统会包含数据以及相应的数据结构和算法，决定着缓存和磁盘数据的平衡。事务处理除了管控数据外，还需要保证数据库的“ACID”性质，并行处理数据时给数据上锁，确保数据被正确写入磁盘。</li><li>此时的SQL已经获得了数据并且开始相应的计算，返回相应的结果给调用者。</li></ol><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是我对Mysql的执行流程的一点见解，对于一条SQL语句的生命周期还有很多细节，欢迎小伙伴在评论区补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql的执行流程&quot;&gt;&lt;a href=&quot;#Mysql的执行流程&quot; class=&quot;headerlink&quot; title=&quot;Mysql的执行流程&quot;&gt;&lt;/a&gt;Mysql的执行流程&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Mysql" scheme="https://wrysmile2.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql的存储引擎</title>
    <link href="https://wrysmile2.github.io/posts/67748aab.html"/>
    <id>https://wrysmile2.github.io/posts/67748aab.html</id>
    <published>2023-09-24T02:26:09.000Z</published>
    <updated>2023-09-30T01:03:17.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Mysql有九种存储引擎，不同的存储引擎，使用与不同的场景，我们平时常用的，可能就是InnoDB，从Mysql5.5开始，就成为了Mysql的默认存储引擎。使用<strong>show engines</strong>命令可以查询Mysql的这几种存储引擎，从表头能看出开，都是yes的就是InnoDB存储引擎。</p><h3 id="Mysql的存储引擎种类和区别"><a href="#Mysql的存储引擎种类和区别" class="headerlink" title="Mysql的存储引擎种类和区别"></a>Mysql的存储引擎种类和区别</h3><p>我们在使用数据库时，通常使用的存储引擎有三种，分别是InnoDB、MyISAM、MRMORY，下面我们来具体了解一下这三种引擎。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th></tr></thead><tbody><tr><td>事务安全</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>对外间的支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>高</td></tr><tr><td>插入数据的速度</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><h3 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h3><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。</p><p>InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p><ol><li><p>更新密集的表，InnoDB存储引擎特别适合处理多并发的更新请求。</p></li><li><p>事务。InnoDB存储引擎是支持事务的标准Mysql存储引擎</p></li><li><p>自然灾难恢复。与其他存储引擎不同，InnoDB表能够自动从灾难中恢复。</p></li><li><p>外键约束。Mysql支持外键的存储引擎只有InnoDB。</p></li><li><p>支持自然增加列AUTO_INCREMENT属性</p></li><li><p>从Mysql5.7开始InnoDB存储引擎成为默认的存储引擎</p></li></ol><p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是很好的选择。</p><h3 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h3><p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。</p><p>每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。</p><p>例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p><ul><li>tb_demo.frm，存储表定义。</li><li>tb_demo.MYD，存储数据。</li><li>tb_demo.MYI，存储索引。</li></ul><p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p><ol><li>选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li><li>插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。</li></ol><p>由此看来，MyISAM存储引擎很适合·管理服务器日志数据</p><h3 id="3-MEMORY"><a href="#3-MEMORY" class="headerlink" title="3.MEMORY"></a>3.MEMORY</h3><p>使用MySQL Memory存储引擎的出发点是速度，为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。当然，获得速度的同时也带来了一些缺陷。</p><p>它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p><p>一般在以下几种情况下使用Memory存储引擎：</p><ol><li>目标数据较小，而且被非常频繁地访问。 在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</li><li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li><li>存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li><li>Memory同时支持散列索引和B树索引。</li></ol><p>B树索引优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;&#x3D;等操作符方便数据挖掘。</p><p>散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在&#x3D;和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mysql的存储引擎共有9种，上述的三种储存引擎是常用的三种，这三种中又以InnoDB使用最多，但是并不是全部都适用，选择存储引擎要根据具体业务来决定。以上就是我对Mysql存储引擎总结的一些知识，有很多不足的地方，欢迎小伙伴在评论区补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql的存储引擎&quot;&gt;&lt;a href=&quot;#Mysql的存储引擎&quot; class=&quot;headerlink&quot; title=&quot;Mysql的存储引擎&quot;&gt;&lt;/a&gt;Mysql的存储引擎&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Mysql" scheme="https://wrysmile2.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis的崩溃问题</title>
    <link href="https://wrysmile2.github.io/posts/711efdca.html"/>
    <id>https://wrysmile2.github.io/posts/711efdca.html</id>
    <published>2023-09-15T00:58:11.000Z</published>
    <updated>2023-09-23T13:07:11.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis的崩溃问题"><a href="#Redis的崩溃问题" class="headerlink" title="Redis的崩溃问题"></a>Redis的崩溃问题</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>redis在我们日常的开发中通常作为缓存来分担数据库的压力，但是redis本身的并发能力也是有限度的，当访问量过大时，就会造成一系列的问题，常见问题有缓存穿透、缓存击穿、缓存雪崩，下面我们就来介绍这几种常见问题，并给出相应的解决办法。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指当有数据访问时，在redis中访问不存在且在数据库中访问也不存在，导致每次访问都直接访问数据库，从而返回空值。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>布隆过滤器</p><p>将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p>返回空对象</p><p>如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。缓存空对象带来的问题：</p><ul><li>空值做了缓存，那么缓存中便存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</li><li>缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。可以利用消息系统或者其他方式清除掉缓存层中的空对象。</li></ul></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指有一个热点key，加大并发对这种key的访问，当这种key失效的时候，巨大的并发就会直面冲击数据库，讲数据库冲垮，导致数据库宕机。</p><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>互斥锁</p><p>缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。</p></li><li><p>“永远不过期”</p><ul><li>从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</li><li>从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期。</li></ul></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存中存在大量的经常访问的key，当这些key在同一时间失效时，巨大的访问量就会直接落在数据库上，是数据库崩溃。</p><h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>均匀过期</p><p>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</p></li><li><p>双层缓存策略、二级缓存</p><p>Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，Cache1 缓存失效时间设置为短期，Cache2 设置为长期。</p></li><li><p>加互斥锁</p><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待；</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis的崩溃问题&quot;&gt;&lt;a href=&quot;#Redis的崩溃问题&quot; class=&quot;headerlink&quot; title=&quot;Redis的崩溃问题&quot;&gt;&lt;/a&gt;Redis的崩溃问题&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="https://wrysmile2.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis的内存淘汰策略</title>
    <link href="https://wrysmile2.github.io/posts/153f114c.html"/>
    <id>https://wrysmile2.github.io/posts/153f114c.html</id>
    <published>2023-09-14T04:58:45.000Z</published>
    <updated>2023-09-23T13:07:40.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Redis是一个基于内存的高性能非关系型数据库，主要的特点是高可用，速度快，分布式；在通常的开发中用作缓存来分担数据库的压力。一般情况下，当内存超出物理内存限制时，内存数据将与磁盘产生频繁交换(swap)，swap会导致redis性能急剧下降，对于访问量较大的情况下，swap的存取效率会让服务基本处于不可用的状态。  </p><p>在生产环境中，一般不允许redis出现swap行为，redis提供了 maxmemory 设置其最多可占用的内存空间。  </p><p>当redis使用的内存超出maxmemory时，此时已经没有多余可用的内存空间，新的数据将无法写入，redis提供了几种数据淘汰策略，用于清理数据，腾出空间以继续提供服务。</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ol><li><p>noeviction</p><p>可读不可写，即不会继续服务写请求，读请求可以继续进行。该策略不会是数据丢失，但由于生产的写请求不可用也同样无法让业务在进行下去，这种策略是默认的。</p></li><li><p>volatile-lru</p><p>淘汰具有过期时间的key，最少使用的key优先淘汰，没有过期时间的key不会被淘汰，该策略可以保证持久化的数据不被丢失。</p></li><li><p>volatile-ttl</p><p>与volatile-lru类似，二者区别是比较过期时间ttl的值，值越小的数据优先淘汰</p></li><li><p>volatile-random</p><p>与2、3类似，区别是随机淘汰有过期时间的key，但不考虑使用频率和过期时间的长短</p></li><li><p>allkeys-lru</p><p>与2类似，区别是该淘汰策略是淘汰redis中所有的key，不区分过期时间，但是区分使用频率。</p></li><li><p>与 5 类似，范围是所有的key，但是不区分使用频率。</p></li></ol><p>volatile开头的只会淘汰带有过期时间的key，allkeys则是所有的key，如果redis只是作为缓存使用，可以使用allkeys，如果有些数据是务必持久化的，则使用volatile。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis的内存淘汰策略&quot;&gt;&lt;a href=&quot;#Redis的内存淘汰策略&quot; class=&quot;headerlink&quot; title=&quot;Redis的内存淘汰策略&quot;&gt;&lt;/a&gt;Redis的内存淘汰策略&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="https://wrysmile2.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化机制</title>
    <link href="https://wrysmile2.github.io/posts/e5adb42e.html"/>
    <id>https://wrysmile2.github.io/posts/e5adb42e.html</id>
    <published>2023-09-12T01:15:51.000Z</published>
    <updated>2023-09-23T13:07:27.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们都知道，Redis 的数据存储在内存中, 一旦服务器宕机，内存中的数据将全部丢失。因此，对 Redis 来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。本篇我们详细讲解下 Redis 的三种持久化机制，分别是 AOF（Append Only File） 日志和 RDB 快照 以及 混合持久化。</p><h3 id="AOF机制"><a href="#AOF机制" class="headerlink" title="AOF机制"></a>AOF机制</h3><p>AOF 日志是写后日志，也就是 Redis 先执行命令，然后将数据写入内存，最后才记录日志，重启时通过执行 AOF 文件中的 Redis 命令来恢复数据。如下图所示：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10418638/693b4cb76c16876336e4c5a3a06fed27.png"></p><p>类似MySql bin-log 的原理，AOF 能够解决数据持久化实时性问题，是目前 Redis 持久化机制中主流的方案。</p><h3 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h3><p>AOF 持久化方案进行备份时，客户端所有请求的写命令都会被追加到 AOF 缓冲区中，缓冲区中的数据会根据 Redis 配置文件中配置的同步策略来同步到磁盘上的 AOF 文件中，追加保存每次写的操作到文件末尾。当 AOF 的文件达到重写策略配置的阈值时，Redis 会对 AOF 日志文件进行重写，给 AOF 日志文件瘦身。Redis 服务重启的时候，通过加载 AOF 日志文件来恢复数据。如下图所示：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10418638/bc15aa10e9c9d41ef356faa07b60cb82.png"></p><h3 id="Redis-AOF-执行流程"><a href="#Redis-AOF-执行流程" class="headerlink" title="Redis AOF 执行流程"></a>Redis AOF 执行流程</h3><p>AOF 为了避免额外的检查开销，并不会检查命令的正确性，如果先记录日志再执行命令，就有可能记录错误的命令，再通过 AOF 日志恢复数据的时候，就有可能出错，而且在执行完命令后记录日志也不会阻塞当前的写操作。但是 AOF 是存在一定的风险的，首先是如果刚执行一个命令，但是 AOF 文件中还没来得及保存就宕机了，那么这个命令和数据就会有丢失的风险，另外 AOF 虽然可以避免对当前命令的阻塞（因为是先写入再记录日志），但有可能会对下一次操作带来阻塞风险（可能存在写入磁盘较慢的情况）。这两种情况都在于 AOF 什么时候写入磁盘，针对这个问题 AOF 机制提供了三种同步策略（appendfsync 参数）。</p><h3 id="AOF-写入磁盘的同步策略"><a href="#AOF-写入磁盘的同步策略" class="headerlink" title="AOF 写入磁盘的同步策略"></a>AOF 写入磁盘的同步策略</h3><table><thead><tr><th>参数</th><th>同步策略</th></tr></thead><tbody><tr><td>Always</td><td>同步写入磁盘，只要有写入就会调用fsync函数；</td></tr><tr><td>Everysec</td><td>每秒调用fsync函数一次，每个命令执行完，先把日志写入 AOF 文件的缓冲区，每隔一秒把缓冲区的内容写入磁盘</td></tr><tr><td>No</td><td>不调用fsync，让操作系统决定何时同步磁盘。每个命令执行完，先将日志写入 AOF 文件的缓冲区，由操作系统决定何时把缓冲区的内容写入磁盘</td></tr></tbody></table><h3 id="三种同步策略的优缺点如下："><a href="#三种同步策略的优缺点如下：" class="headerlink" title="三种同步策略的优缺点如下："></a>三种同步策略的优缺点如下：</h3><ul><li>Always：可靠性较高，数据基本不丢失，但是对性能影响较大</li><li>Everysec：性能适中，及时宕机也只会丢失一秒的数据</li><li>No：性能好，但发生当即情况时，</li></ul><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>我们上面说过，AOF 属于日志追加的形式来存储 Redis 的写指令，虽然有一定的写回策略，但毕竟 AOF 是通过文件的形式记录所有的写命令，但如果指令越来越多的时候，AOF 文件就会越来越大，可能会超出文件大小的限制。如果发生宕机，需要把 AOF 所有的命令重新执行，以用于故障恢复，数据过大的话这个恢复过程越漫长，也会影响 Redis 的使用。因此 Redis 提供 <strong>重写机制</strong>来解决这个问题。</p><p>AOF 重写的过程是通过主线程 fork 后台的 bgrewriteaof 子进程来实现的，可以避免阻塞主进导致性能下降，整个过程如下：</p><ul><li><p>AOF 每次重写，fork 过程会把主线程的内存拷贝一份 bgrewriteaof 子进程，里面包含了数据库的数据，拷贝的是父进程的页表，可以在不影响主进程的情况下逐一把拷贝的数据记入重写日志；</p></li><li><p>因为主线程没有阻塞，仍然可以处理新来的操作，如果这时候存在写操作，会先把操作先放入缓冲区，对于正在使用的日志，如果宕机了这个日志也是齐全的，可以用于恢复；对于正在更新的日志，也不会丢失新的操作，等到数据拷贝完成，就可以将缓冲区的数据写入到新的文件中，保证数据库的最新状态。</p></li></ul><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><p>为了 RDB 数据恢复的可靠性，在进行快照的时候是全量快照，会将内存中所有的数据都记录到磁盘中，这就有可能会阻塞主线程的执行。Redis 提供了两个命令来生成 RDB 文件，分别是 <strong>save</strong> 和 <strong>bgsave</strong> ：</p><ul><li><strong>save</strong>：执行 save 指令，阻塞 Redis 的其他操作，会导致 Redis 无法响应客户端请求，不建议使用。</li><li><strong>bgsave</strong>：执行 bgsave 指令，Redis 后台创建子进程，异步进行快照的保存操作，此时 Redis 仍然能响应客户端的请求。</li></ul><h3 id="自动间隔保存"><a href="#自动间隔保存" class="headerlink" title="自动间隔保存"></a>自动间隔保存</h3><p>Redis 可以设置间隔性保存，让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时，自动保存一次数据集。比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 10 个键被改动”这一条件时，自动保存一次数据集：save 60 10</p><p>Redis 的默认配置如下，三个设置满足其一就会触发自动保存：</p><blockquote><p>save  60  10000</p><p>save  900  10</p><p>save  300  1</p></blockquote><h3 id="RDB模式优点"><a href="#RDB模式优点" class="headerlink" title="RDB模式优点"></a>RDB模式优点</h3><ul><li>相比AOF在恢复数据的时候需要一条条的执行操作命令，通过RDB文件恢复数据的效率更高；</li><li>同样规模的内存数据，RDB文件数据更加紧凑，磁盘空间占用更小；</li><li>适合全量备份内存数据场景；</li><li>可以根据不同的时间间隔保存RDB文件，在恢复数据的时候可以更加灵活地选择对应版本数据进行恢复</li></ul><h3 id="RDB模式缺点"><a href="#RDB模式缺点" class="headerlink" title="RDB模式缺点"></a>RDB模式缺点</h3><ul><li>由于RDB数据保存存在一定的时间间隔，因此存在丢失缓存数据的风险；</li><li>fork子进程进行RDB文件生成，由于是一次性生成一个内存快照文件，对于服务器磁盘IO以及Redis本身来说都属于重操作，可能会对服务器的磁盘IO造成压力。</li></ul><h3 id="混合使用AOF日志和RDB快照"><a href="#混合使用AOF日志和RDB快照" class="headerlink" title="混合使用AOF日志和RDB快照"></a>混合使用AOF日志和RDB快照</h3><p>Redis4.0 后大部分的使用场景都不会单独使用 RDB 或者 AOF 来做持久化机制，而是兼顾二者的优势混合使用。其原因是 RDB 虽然快，但是会丢失比较多的数据，不能保证数据完整性；AOF 虽然能尽可能保证数据完整性，但是性能确实是一个诟病，比如重放恢复数据。  </p><p>Redis从4.0版本开始引入 RDB-AOF 混合持久化模式，这种模式是基于 AOF 持久化模式构建而来的，混合持久化通过 <strong>aof-use-rdb-preamble yes</strong> 开启。这样的好处是 RDB 快照不需要很频繁的执行，可以避免频繁 fork 对主线程的影响，而且 AOF 日志也只记录两次快照期间的操作，不用记录所有操作，也不会出现文件过大的情况，避免了重写开销。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析了Redis AOF、RDB快照 以及混合持久化的内存数据持久化的机制原理，生产环境中推荐使用混合持久化，这种方式综合了RDB和AOF两种方式的优点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis的持久化机制&quot;&gt;&lt;a href=&quot;#Redis的持久化机制&quot; class=&quot;headerlink&quot; title=&quot;Redis的持久化机制&quot;&gt;&lt;/a&gt;Redis的持久化机制&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="中间件" scheme="https://wrysmile2.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="https://wrysmile2.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://wrysmile2.github.io/posts/ff05b5bf.html"/>
    <id>https://wrysmile2.github.io/posts/ff05b5bf.html</id>
    <published>2023-09-10T01:30:07.000Z</published>
    <updated>2023-09-23T07:24:15.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试： </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><p> 图片测试： </p><p><img src="http://mculover666.cn/blog/20191031/R4mWMXsrRKxu.png?imageslim"> 引用测试：</p><blockquote><p>这是一条引用 </p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li><p>哈哈 </p></li><li><p>嘿嘿 </p></li><li><p>吼吼 </p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;p&gt;代码测试： &lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wrysmile2.github.io/posts/4a17b156.html"/>
    <id>https://wrysmile2.github.io/posts/4a17b156.html</id>
    <published>2023-09-05T08:19:42.618Z</published>
    <updated>2023-09-23T07:24:15.906Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
