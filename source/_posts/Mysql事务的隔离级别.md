---
title: Mysql事务的隔离级别
categories:
  - 中间件
tags:
  - Mysql
abbrlink: f3c852d2
date: 2023-09-30 12:49:29
---

# Mysql事务的隔离级别

### 引言

我们之前介绍过Mysql的存储引擎，其中只有InnoDB支持事务，然而提到事务就一定会考虑到隔离级别，今天我们来整理一下Mysql事务的四大隔离级别相关知识，希望对大家有所帮助。

### Mysql事务

数据库事务指的是一组数据操作，事务内的操作要么就全部成功，要么就全部失败，什么都不做，其实不是没做，是可能只做了一部分，但只要有一步失败，就要回滚所有操作。

在事务的使用中，我们会遇到一些相关问题，一般会有三种情况：**脏读**、**不可重复读**、**幻读**，这是事务并发可能会出现的情况。

#### 脏读（Dirty Read）

> 脏读指的是：一个事务读到了另一个未提交事务修改过的数据，未提交意味着这些数据可能会回滚，也可能最终没有保存到数据库中，所以就导致了读到的数据不一定是真实的数据。这就是脏读。

#### 不可重复读

> 可重复读指的是在同一个事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如当一个事务在大量读取数据时，有一其他事务对该数据进行了修改，这就会导致之后读取到的数据会与修改前不一致。这就是不可重复读，通常针对数据更新（update）操作。

#### 幻读

> 幻读是针对数据**插入（insert）**操作来说的。假设事务A对某些数据做了修改，但是还没有提交事务，此时事务B插入了与事务A更改前的记录相同的数据，并且在事务A提交之前提交了，而这时，在事务A中查询，会发现好像刚刚的更改对某些数据不起作用，但这其实是事务B插入进来的，对于用户来说，就想中了幻术一样，这就是幻读。

这三种是事务的实现中会发生的三种异常，使用Mysql定义的隔离级别可以避免它，我们之前讲过，Mysql的事务实现逻辑是位于引擎层的，但不是所有存储引擎都支持事务，下面我们所讲述的隔离级别都是以InnoDB存储引擎来描述。

#### 定义

隔离性（isolation）指的是不同事务先后提交并执行后，最终呈现出来的效果是串行的，也就是说，对于事务来说，它在执行过程中，感知到的数据变化应该只有自己操作引起的，不存在其他事务引发的数据变化。

**隔离性解决的是并发事务出现的问题**。

### SQL的隔离级别

隔离性最简单的实现方式就是各个事务都串行执行了，如果前面的事务还没有执行完毕，后面的事务就都等待。但是这样的实现方式很明显并发效率不高，并不适合在实际环境中使用。

为了解决上述问题，实现不同程度的并发控制，SQL的标准制定者提出了不同的隔离级别：未提交读（read uncommitted）、提交读（read committed）、可重复读（repeatable read）、序列化读（serializable）。其中最高级隔离级别就是序列化读，而在其他隔离级别中，由于事务是并发执行的，所以或多或少允许出现一些问题。见以下的矩阵表：

| 隔离级别（+:允许出现，-：不允许出现） | 脏读 | 不可重复读 | 幻读 |
| :------------------------------------ | :--: | :--------: | :--: |
| 读未提交（RU）                        |  +   |     +      |  +   |
| 读已提交                              |  -   |     +      |  +   |
| 可重复度                              |  -   |     -      |  +   |
| 序列化                                |  -   |     -      |  -   |

**注意，MySQL的InnoDB引擎在提交读级别通过MVCC解决了不可重复读的问题，在可重复读级别通过间隙锁解决了幻读问题，具体见下面的分析**。

#### 实现原理

**标准SQL事务隔离级别实现原理**

我们上面遇到的问题其实就是并发事务下的控制问题，解决并发事务的最常见方式就是悲观并发控制了（也就是数据库中的锁）。标准SQL事务隔离级别的实现是依赖锁的，我们来看下具体是怎么实现的：

| 事务隔离级别   | 实现方式                                                     |
| -------------- | ------------------------------------------------------------ |
| 读未提交（RU） | 事务对当前被读取的数据不加锁； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级共享锁**，直到事务结束才释放。 |
| 读已提交（RC） | 事务对当前被读取的数据加**行级共享锁（当读到时才加锁）**，一旦读完该行，立即释放该行级共享锁； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁**，直到事务结束才释放。 |
| 可重复读（RR） | 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加**行级共享锁**，直到事务结束才释放； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁**，直到事务结束才释放。 |
| 序列化（S）    | 事务在读取数据时，必须先对其加**表级共享锁** ，直到事务结束才释放； 事务在更新数据时，必须先对其加**表级排他锁** ，直到事务结束才释放。 |

可以看到，在只使用锁来实现隔离级别的控制的时候，需要频繁的加锁解锁，而且很容易发生读写的冲突（例如在RC级别下，事务A更新了数据行1，事务B则在事务A提交前读取数据行1都要等待事务A提交并释放锁）。

### 结束

以上就是我对Mysql的隔离级别的一些看法和总结，欢迎小伙伴在评论区补充。
